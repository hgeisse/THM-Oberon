MODULE* BootLoad;
  (* NW 20.10.2013
     PR 04.02.2014: boot from SDHC disk or serial line
     HG 09.06.2018: re-definition of switches
     HG 24.11.2019: send ACK at end of load from serial line
     AP 13.03.2020: eliminate MT and MTOrg, set TR to TrapAdr
     HG 30.05.2020: set file system offset to zero
     HG 28.06.2020: modify for use on ECO32 *)
  IMPORT SYSTEM;
  (* sw1: boot from serial line/not SDHC disk
     sw0: enforce cold boot *)
  CONST
    TR = 28;
    SP = 29;
    LNK = 31;
    TrapAdr = 0C0000008H;
    MemLim = 0C00E7EF0H;
    stackOrg = 0C0080000H;
    swi = 0F1000000H;
    RxStatus = 0F0300000H;
    RxData = 0F0300004H;
    TxStatus = 0F0300008H;
    TxData = 0F030000CH;
    ramStart = 0C0000000H;
    ramDiskStart = 0C0200000H; (* RAM disk start: 2MB *)
    FSoffset = 0H;  (* file system offset, in 512-byte SD card blocks *)
    ACK = 10H;

(* ---------- line ------------ *)

  PROCEDURE RecByte(VAR x: BYTE);
    VAR y: INTEGER;
  BEGIN
    REPEAT
    UNTIL SYSTEM.BIT(RxStatus, 0);
    SYSTEM.GET(RxData, y);
    x := y;
  END RecByte;

  PROCEDURE RecInt(VAR x: INTEGER);
    VAR z, y, i: INTEGER; b: BYTE;
  BEGIN
    z := 0;
    i := 4;
    REPEAT
      i := i-1;
      RecByte(b);
      y := b;
      z := ROR(z+y, 8)
    UNTIL i = 0;
    x := z
  END RecInt;

  PROCEDURE SndByte(x: BYTE);
    VAR v: INTEGER;
  BEGIN
    REPEAT
    UNTIL SYSTEM.BIT(TxStatus, 0);
    v := x;
    SYSTEM.PUT(TxData, v)
  END SndByte;

  PROCEDURE LoadFromLine;
    VAR len, adr: INTEGER; dat: BYTE;
  BEGIN
    RecInt(len);
    WHILE len > 0 DO
      RecInt(adr);
      adr := adr + 0C0000000H;  (* convert phys addr to virt addr *)
      REPEAT
        RecByte(dat);
        SYSTEM.PUT(adr, dat);
        adr := adr + 1;
        len := len - 1
      UNTIL len = 0;
      RecInt(len)
    END;
    SndByte(ACK)
  END LoadFromLine;

(* ---------- disk ------------ *)

  PROCEDURE Read512(src, dst: INTEGER);
    (* src: block #, dst: address of buffer *)
    VAR
      dskAddr: INTEGER;
      i: INTEGER;
      data: INTEGER;
  BEGIN
    dskAddr := ramDiskStart + src * 512;
    FOR i := 0 TO 511 BY 4 DO
      SYSTEM.GET(dskAddr, data);
      INC(dskAddr, 4);
      SYSTEM.PUT(dst, data);
      INC(dst, 4);
    END;
  END Read512;

  PROCEDURE LoadFromDisk;
    VAR src, dst, lim: INTEGER;
  BEGIN
    src := FSoffset + 4;  (* start at boot block *)
    dst := ramStart;
    Read512(src, dst);
    SYSTEM.GET(16, lim);
    INC(src);
    INC(dst, 512);
    WHILE dst < lim DO
      Read512(src, dst);
      INC(src);
      INC(dst, 512)
    END
  END LoadFromDisk;

(* ---------- load ------------ *)

BEGIN
  SYSTEM.LDREG(SP, stackOrg);
  SYSTEM.LDREG(TR, TrapAdr);
  IF SYSTEM.BIT(swi, 0) THEN
    (* enforce cold start *)
    SYSTEM.LDREG(LNK, 0)
  END;
  IF SYSTEM.REG(LNK) = 0 THEN
    (* cold start *)
    LED(80H);
    (*InitSPI;!!!!! HG !!!!!*)
    IF SYSTEM.BIT(swi, 1) THEN
      (* loading from serial line requested *)
      LED(81H);
      LoadFromLine
    ELSE
      (* loading from disk requested *)
      LED(82H);
      LoadFromDisk
    END
  END;
  SYSTEM.PUT(0C000000CH, MemLim);
  SYSTEM.PUT(0C0000018H, stackOrg);
  LED(84H);
  (* sync caches *)
  SYSTEM.CCTL(7)
END BootLoad.
